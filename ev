-- ********************************************************************************** --
-- **                                                                              ** --
-- **   Minecraft Mining Turtle Ore Quarry v0.53 by AustinKK                       ** --
-- **   ----------------------------------------------------                       ** -- 
-- **                                                                              ** --
-- **   For instructions on how to use:                                            ** --
-- **                                                                              ** --
-- **     http://www.youtube.com/watch?v=PIugLVzUz3g                               ** --
-- **                                                                              ** --
-- **  Change Log:                                                                 ** --
-- **    27th Dec 2012: [v0.2] Initial Draft Release                               ** --
-- **    29th Dec 2012: [v0.3] Minor Performance Improvements                      ** --
-- **    30th Dec 2012: [v0.4] Further Performance Improvements                    ** --
-- **    9th  Jan 2013: [v0.5] Debug Version (dropping off chest)                  ** --
-- **    10th Jan 2013: [v0.51] Further Debug (dropping off chest)                 ** --
-- **    10th Jan 2013: [v0.52] Fix for dropping off chest bug                     ** --
-- **    11th Jan 2013: [v0.53] Released fix for chest bug                         ** --
-- **                                                                              ** --
-- ********************************************************************************** --

-- Enumeration to store the the different types of message that can be written
messageLevel = { DEBUG=0, INFO=1, WARNING=2, ERROR=3, FATAL=4 }
 
-- Enumeration to store names for the 6 directions
direction = { FORWARD=0, RIGHT=1, BACK=2, LEFT=3, UP=4, DOWN=5 }
 
local messageOutputLevel = messageLevel.INFO
local messageOutputFileName
local fuelLevelToRefuelAt = 5
local refuelItemsToUseWhenRefuelling = 63
local emergencyFuelToRetain = 0
local maximumGravelStackSupported = 25 -- The number of stacked gravel or sand blocks supported
local noiseBlocksCount
local bottomLayer = 5 -- The y co-ords of the layer immediately above bedrock
local returningToStart = false
local lookForChests = false -- Determines if chests should be located as part of the quarrying
local miningOffset -- The offset to the mining layer. This is set depending on whether chests are being looked for or not
local lastEmptySlot -- The last inventory slot that was empty when the program started (is either 15 if not looking for chests or 14 if we are)
local turtleId
local currentlySelectedSlot = 0 -- The slot that the last noise block was found in
local lastMoveNeededDig = true -- Determines whether the last move needed a dig first
local haveBeenAtZeroZeroOnLayer -- Determines whether the turtle has been at (0, 0) in this mining layer
local orientationAtZeroZero -- The turtle's orientation when it was at (0, 0)
local levelToReturnTo -- The level that the turtle should return to in order to head back to the start to unload

-- Variables to store the current location and orientation of the turtle. x is right, left, y is up, down and
-- z is forward, back with relation to the starting orientation. Y is the actual turtle level, x and z are
-- in relation to the starting point (i.e. the starting point is (0, 0))
local currX
local currY
local currZ
local currOrient
 
-- Command line parameters
local startHeight -- Represents the height (y co-ord) that the turtle started at
local quarryWidth -- Represents the length of the mines that the turtle will dig
 
-- ********************************************************************************** --
-- Writes an output message
-- ********************************************************************************** --
function writeMessage(message, msgLevel)
  if (msgLevel >= messageOutputLevel) then
    print(message)
    if (turtleId == nil) then
      rednet.broadcast(message)
    else
      -- Broadcast the message (prefixed with the turtle's id)
      rednet.broadcast("[".. turtleId.."] "..message)
    end

    if (messageOutputFileName ~= nil) then
      -- Open file, write message and close file (flush doesn't seem to work!)
      local outputFile = io.open(messageOutputFileName, "a")
      outputFile:write(message)
      outputFile:write("\n")
      outputFile:close()
    end
  end
end
 
-- ********************************************************************************** --
-- Ensures that the turtle has fuel
-- ********************************************************************************** --
function ensureFuel()
    if turtle.getFuelLevel() == 0 then
        while turtle.getItemCount(16) == 0 do
            clearScreen()
            print("Waiting for fuel, press enter when ready")
            read()
        end
        turtle.select(16)
        turtle.refuel(1)
        return true
    end
    return true
end        
 

function clearScreen()
    term.clear()
    writeAt("Build",5,1)
    term.setCursorPos( 1, 3 )
end
 
-- ********************************************************************************** --
-- Checks that the turtle has inventory space by checking for spare slots and returning
-- to the starting point to empty out if it doesn't.
--
-- Takes the position required to move to in order to empty the turtle's inventory
-- should it be full as arguments
-- ********************************************************************************** --
function ensureInventorySpace()
 
  -- If already returning to start, then don't need to do anything
  if (returningToStart == false) then
 
    -- If the last inventory slot is full, then need to return to the start and empty
    if (turtle.getItemCount(lastEmptySlot) > 0) then
 
      -- Return to the starting point and empty the inventory, then go back to mining
      returnToStartAndUnload(true)
    end
  end
end
 
-- ********************************************************************************** --
-- Function to move to the starting point, call a function that is passed in
-- and return to the same location (if required)
-- ********************************************************************************** --
function returnToStartAndUnload(returnBackToMiningPoint)
 
  writeMessage("returnToStartAndUnload called", messageLevel.DEBUG)
  returningToStart = true

  -- Store the current location and orientation so that it can be returned to
  local storedX = currX
  local storedY = currY
  local storedZ = currZ
  local storedOrient = currOrient
 
  writeMessage("Return to start, return level: "..levelToReturnTo, messageLevel.DEBUG)

  -- Move down to the correct layer to return via
  if (currY > levelToReturnTo) then
    while (currY > levelToReturnTo) do
      turtleDown()
    end
  elseif (currY < levelToReturnTo) then 
    while (currY < levelToReturnTo) do
      turtleUp()
    end
  end
 
  if ((haveBeenAtZeroZeroOnLayer == false) or (orientationAtZeroZero == direction.FORWARD)) then
    -- Move back to the correct X position first
    if (currX > 0) then
      turtleSetOrientation(direction.LEFT)
      while (currX > 0) do
        turtleForward()
      end
    elseif (currX < 0) then
      -- This should never happen
      writeMessage("Current x is less than 0 in returnToStartAndUnload", messageLevel.ERROR)
    end
 
    -- Then move back to the correct Z position
    if (currZ > 0) then
      turtleSetOrientation(direction.BACK)
      while (currZ > 0) do
        turtleForward()
      end
    elseif (currZ < 0) then
      -- This should never happen
      writeMessage("Current z is less than 0 in returnToStartAndUnload", messageLevel.ERROR)
    end
  else
    -- Move back to the correct Z position first
    if (currZ > 0) then
      turtleSetOrientation(direction.BACK)
      while (currZ > 0) do
        turtleForward()
      end
    elseif (currZ < 0) then
      -- This should never happen
      writeMessage("Current z is less than 0 in returnToStartAndUnload", messageLevel.ERROR)
    end

    -- Then move back to the correct X position
    if (currX > 0) then
      turtleSetOrientation(direction.LEFT)
      while (currX > 0) do
        turtleForward()
      end
    elseif (currX < 0) then
      -- This should never happen
      writeMessage("Current x is less than 0 in returnToStartAndUnload", messageLevel.ERROR)
    end
  end
 
  -- Return to the starting layer
  if (currY < startHeight) then
    while (currY < startHeight) do
      turtleUp()
    end
  elseif (currY > startHeight) then
    -- This should never happen
    writeMessage("Current height is greater than start height in returnToStartAndUnload", messageLevel.ERROR)
  end
 
  -- Empty the inventory
  local slotLoop = 1
 
  -- Face the chest
  turtleSetOrientation(direction.BACK)
 
  -- Loop over each of the slots (except the 16th one which stores fuel)
  while (slotLoop < 16) do
    -- If this is one of the slots that contains a noise block, empty all blocks except
    -- one
    turtle.select(slotLoop) -- Don't bother updating selected slot variable as it will set later in this function
    if ((slotLoop <= noiseBlocksCount) or ((slotLoop == 15) and (lastEmptySlot == 14))) then
      writeMessage("Dropping (n-1) from slot "..slotLoop.." ["..turtle.getItemCount(slotLoop).."]", messageLevel.DEBUG)  
      turtle.drop(turtle.getItemCount(slotLoop) - 1)
    else
      -- Not a noise block, drop all of the items in this slot
      writeMessage("Dropping (all) from slot "..slotLoop.." ["..turtle.getItemCount(slotLoop).."]", messageLevel.DEBUG)  
      turtle.drop()
    end
     
    slotLoop = slotLoop + 1
  end

  -- While we are here, refill the fuel items if there is capacity
  if (turtle.getItemCount(16) < 64) then
    turtleSetOrientation(direction.LEFT)
    turtle.select(16) -- Don't bother updating selected slot variable as it will set later in this function
    local currFuelItems = turtle.getItemCount(16)
    turtle.suck()
    while ((currFuelItems ~= turtle.getItemCount(16)) and (turtle.getItemCount(16) < 64)) do
      currFuelItems = turtle.getItemCount(16)
      turtle.suck()
    end
 
    slotLoop = noiseBlocksCount + 1
    -- Have now picked up all the items that we can. If we have also picked up some
    -- additional fuel in some of the other slots, then drop it again
    while (slotLoop <= lastEmptySlot) do
      -- Drop any items found in this slot
      turtle.select(slotLoop) -- Don't bother updating selected slot variable as it will set later in this function
      turtle.drop()
      slotLoop = slotLoop + 1
    end
  end

  -- Select the 1st slot because sometimes when leaving the 15th or 16th slots selected it can result
  -- in that slot being immediately filled (resulting in the turtle returning to base again too soon)
  turtle.select(1)
  currentlySelectedSlot = 1
 
  -- If required, move back to the point that we were mining at before returning to the start
  if (returnBackToMiningPoint == true) then
    -- Return back to the required layer
    while (currY > levelToReturnTo) do
      turtleDown()
    end

    if ((haveBeenAtZeroZeroOnLayer == false) or (orientationAtZeroZero == direction.FORWARD)) then
      -- Move back to the correct Z position first
      writeMessage("Stored Z: "..storedZ..", currZ: "..currZ, messageLevel.DEBUG)
      if (storedZ > currZ) then
        writeMessage("Orienting forward", messageLevel.DEBUG)
        writeMessage("Moving in z direction", messageLevel.DEBUG)
        turtleSetOrientation(direction.FORWARD)
        while (storedZ > currZ) do
          turtleForward()
        end
      elseif (storedZ < currZ) then
        -- This should never happen
        writeMessage("Stored z is less than current z in returnToStartAndUnload", messageLevel.ERROR)
      end

      -- Then move back to the correct X position
      if (storedX > currX) then
        writeMessage("Stored X: "..storedX..", currX: "..currX, messageLevel.DEBUG)
        writeMessage("Orienting right", messageLevel.DEBUG)
        writeMessage("Moving in x direction", messageLevel.DEBUG)
        turtleSetOrientation(direction.RIGHT)
        while (storedX > currX) do
          turtleForward()
        end
      elseif (storedX < currX) then
        -- This should never happen
        writeMessage("Stored x is less than current x in returnToStartAndUnload", messageLevel.ERROR)
      end
    else 
      -- Move back to the correct X position first
      if (storedX > currX) then
        writeMessage("Stored X: "..storedX..", currX: "..currX, messageLevel.DEBUG)
        writeMessage("Orienting right", messageLevel.DEBUG)
        writeMessage("Moving in x direction", messageLevel.DEBUG)
        turtleSetOrientation(direction.RIGHT)
        while (storedX > currX) do
          turtleForward()
        end
      elseif (storedX < currX) then
        -- This should never happen
        writeMessage("Stored x is less than current x in returnToStartAndUnload", messageLevel.ERROR)
      end
 
      -- Then move back to the correct Z position
      writeMessage("Stored Z: "..storedZ..", currZ: "..currZ, messageLevel.DEBUG)
      if (storedZ > currZ) then
        writeMessage("Orienting forward", messageLevel.DEBUG)
        writeMessage("Moving in z direction", messageLevel.DEBUG)
        turtleSetOrientation(direction.FORWARD)
        while (storedZ > currZ) do
          turtleForward()
        end
      elseif (storedZ < currZ) then
        -- This should never happen
        writeMessage("Stored z is less than current z in returnToStartAndUnload", messageLevel.ERROR)
      end
    end
 
    -- Move back to the correct layer
    if (storedY < currY) then
      while (storedY < currY) do
        turtleDown()
      end
    elseif (storedY > currY) then 
      while (storedY > currY) do
        turtleUp()
      end
    end
 
    -- Finally, set the correct orientation
    turtleSetOrientation(storedOrient)
 
    writeMessage("Have returned to the mining point", messageLevel.DEBUG)
  end
 
  returningToStart = false
 
end
 
-- ********************************************************************************** --
-- Empties a chest's contents
-- ********************************************************************************** --
function emptyChest(suckFn)
 
  local prevInventoryCount = {}
  local inventoryLoop
  local chestEmptied = false
 
  -- Record the number of items in each of the inventory slots
  for inventoryLoop = 1, 16 do
    prevInventoryCount[inventoryLoop] = turtle.getItemCount(inventoryLoop)
  end
 
  while (chestEmptied == false) do
    -- Pick up the next item
    suckFn()
 
    -- Determine the number of items in each of the inventory slots now
    local newInventoryCount = {}
    for inventoryLoop = 1, 16 do
      newInventoryCount[inventoryLoop] = turtle.getItemCount(inventoryLoop)
    end
 
    -- Now, determine whether there have been any items taken from the chest
    local foundDifferentItemCount = false
    inventoryLoop = 1
    while ((foundDifferentItemCount == false) and (inventoryLoop <= 16)) do
      if (prevInventoryCount[inventoryLoop] ~= newInventoryCount[inventoryLoop]) then
        foundDifferentItemCount = true
      else
        inventoryLoop = inventoryLoop + 1
      end
    end
   
    -- If no items have been found with a different item count, then the chest has been emptied
    chestEmptied = not foundDifferentItemCount
 
    if (chestEmptied == false) then
      prevInventoryCount = newInventoryCount
      -- Check that there is sufficient inventory space as may have picked up a block
      ensureInventorySpace()
    end
  end
 
  writeMessage("Finished emptying chest", messageLevel.DEBUG)
end
 
 
-- ********************************************************************************** --
-- Generic function to move the Turtle (pushing through any gravel or other
-- things such as mobs that might get in the way).
--
-- The only thing that should stop the turtle moving is bedrock. Where this is
-- found, the function will return after 15 seconds returning false
-- ********************************************************************************** --
function moveTurtle(moveFn, detectFn, digFn, attackFn, compareFn, suckFn, maxDigCount)
 
  ensureFuel()
 
  -- Flag to determine whether digging has been tried yet. If it has
  -- then pause briefly before digging again to allow sand or gravel to
  -- drop
  local digCount = 0
  local moveSuccess = false

  if (lastMoveNeededDig == false) then
    -- Didn't need to dig last time the turtle moved, so try moving first
    moveSuccess = moveFn()

    -- Don't need to set the last move needed dig. It is already false, if 
    -- move success is now true, then it won't be changed
  else    
    -- If we are looking for chests, then check that this isn't a chest before trying to dig it
    if (lookForChests == true) then
      if (isNoiseBlock(compareFn) == false) then
        if (detectFn() == true) then
          -- Determine if it is a chest before digging it
          if (isChestBlock(compareFn) == true) then
            -- Have found a chest, empty it before continuing
            emptyChest (suckFn)
          end
        end
      end
    end
 
    -- Try to dig (without doing a detect as it is quicker)
    local digSuccess = digFn()
    if (digSuccess == true) then
      digCount = 1
    end
    moveSuccess = moveFn()

    if (moveSuccess == true) then
      lastMoveNeededDig = digSuccess
    end
  end
 
  -- Loop until we've successfully moved
  if (moveSuccess == false) then
    while ((moveSuccess == false) and (digCount < maxDigCount)) do
 
      -- If there is a block in front, dig it
      if (detectFn() == true) then
       
          -- If we've already tried digging, then pause before digging again to let
          -- any sand or gravel drop, otherwise check for a chest before digging
          if(digCount == 0) then
            -- Am about to dig a block - check that it is not a chest if necessary
            -- If we are looking for chests, then check that this isn't a chest before moving
            if (lookForChests == true) then
              if (isNoiseBlock(compareFn) == false) then
                if (detectFn() == true) then
                  -- Determine if it is a chest before digging it
                  if (isChestBlock(compareFn) == true) then
                    -- Have found a chest, empty it before continuing
                    emptyChest (suckFn)
                  end
                end
              end
            end
          else
            sleep(0.1)
          end
 
          digFn()
          digCount = digCount + 1
      else
         -- Am being stopped from moving by a mob, attack it
         attackFn()
      end
 
      -- Try the move again
      moveSuccess = moveFn()
    end

    if (digCount == 0) then
      lastMoveNeededDig = false
    else
      lastMoveNeededDig = true
    end
  end
 
  -- Return the move success
  return moveSuccess
 
end
 
-- ********************************************************************************** --
-- Move the turtle forward one block (updating the turtle's position)
-- ********************************************************************************** --
function turtleForward()
  local returnVal = moveTurtle(turtle.forward, turtle.detect, turtle.dig, turtle.attack, turtle.compare, turtle.suck, maximumGravelStackSupported)
  if (returnVal == true) then
    -- Update the current co-ordinates
    if (currOrient == direction.FORWARD) then
      currZ = currZ + 1
    elseif (currOrient == direction.LEFT) then
      currX = currX - 1
    elseif (currOrient == direction.BACK) then
      currZ = currZ - 1
    elseif (currOrient == direction.RIGHT) then
      currX = currX + 1
    else
      writeMessage ("Invalid currOrient in turtleForward function", messageLevel.ERROR)
    end
 
    -- Check that there is sufficient inventory space as may have picked up a block
    ensureInventorySpace()
  end
 
  return returnVal
end
 
-- ********************************************************************************** --
-- Move the turtle up one block (updating the turtle's position)
-- ********************************************************************************** --
function turtleUp()
  local returnVal = moveTurtle(turtle.up, turtle.detectUp, turtle.digUp, turtle.attackUp, turtle.compareUp, turtle.suckUp, maximumGravelStackSupported)
  if (returnVal == true) then
    currY = currY + 1
 
    -- Check that there is sufficient inventory space as may have picked up a block
    ensureInventorySpace()
  end
  return returnVal
end
 
-- ********************************************************************************** --
-- Move the turtle down one block (updating the turtle's position)
-- ********************************************************************************** --
function turtleDown()
  local returnVal
 
  -- Because the turtle is digging down, can fail fast (only allow 1 dig attempt).
  returnVal = moveTurtle(turtle.down, turtle.detectDown, turtle.digDown, turtle.attackDown, turtle.compareDown, turtle.suckDown, 1)
  if (returnVal == true) then
    currY = currY - 1
 
    -- Check that there is sufficient inventory space as may have picked up a block
    ensureInventorySpace()
  end
  return returnVal
end
 
-- ********************************************************************************** --
-- Move the turtle back one block (updating the turtle's position)
-- ********************************************************************************** --
function turtleBack()
  -- First try to move back using the standard function
  local returnVal = turtle.back()
 
  -- Moving back didn't work (might be a block or a mob in the way). Turn round and move
  -- forward instead (whereby anything in the way can be cleared)
  if(returnVal == false) then
    turtle.turnRight()
    turtle.turnRight()
    returnVal = turtleForward()
    turtle.turnRight()
    turtle.turnRight()
  end  
 
  if (returnVal == true) then
    -- Update the current co-ordinates
    if (currOrient == direction.FORWARD) then
      currZ = currZ - 1
    elseif (currOrient == direction.LEFT) then
      currX = currX + 1
    elseif (currOrient == direction.BACK) then
      currZ = currZ + 1
    elseif (currOrient == direction.RIGHT) then
      currX = currX - 1
    else
      writeMessage ("Invalid currOrient in turtleBack function", messageLevel.ERROR)
    end
 
    -- Check that there is sufficient inventory space as may have picked up a block
    ensureInventorySpace()
  end
   
  return returnVal
end
 
-- ********************************************************************************** --
-- Turns the turtle (updating the current orientation at the same time)
-- ********************************************************************************** --
function turtleTurn(turnDir)
 
  if (turnDir == direction.LEFT) then
    if (currOrient == direction.FORWARD) then
      currOrient = direction.LEFT
      turtle.turnLeft()
    elseif (currOrient == direction.LEFT) then
      currOrient = direction.BACK
      turtle.turnLeft()
    elseif (currOrient == direction.BACK) then
      currOrient = direction.RIGHT
      turtle.turnLeft()
    elseif (currOrient == direction.RIGHT) then
      currOrient = direction.FORWARD
      turtle.turnLeft()
    else
      writeMessage ("Invalid currOrient in turtleTurn function", messageLevel.ERROR)
    end
  elseif (turnDir == direction.RIGHT) then
    if (currOrient == direction.FORWARD) then
      currOrient = direction.RIGHT
      turtle.turnRight()
    elseif (currOrient == direction.LEFT) then
      currOrient = direction.FORWARD
      turtle.turnRight()
    elseif (currOrient == direction.BACK) then
      currOrient = direction.LEFT
      turtle.turnRight()
    elseif (currOrient == direction.RIGHT) then
      currOrient = direction.BACK
      turtle.turnRight()
    else
      writeMessage ("Invalid currOrient in turtleTurn function", messageLevel.ERROR)
    end
  else
    writeMessage ("Invalid turnDir in turtleTurn function", messageLevel.ERROR)
  end
end
 
-- ********************************************************************************** --
-- Sets the turtle to a specific orientation, irrespective of its current orientation
-- ********************************************************************************** --
function turtleSetOrientation(newOrient)
 
  if (currOrient ~= newOrient) then
    if (currOrient == direction.FORWARD) then
      if (newOrient == direction.RIGHT) then
        turtle.turnRight()
        currOrient = newOrient
      elseif (newOrient == direction.BACK) then
        turtle.turnRight()
        turtle.turnRight()
        currOrient = newOrient
      elseif (newOrient == direction.LEFT) then
        turtle.turnLeft()
        currOrient = newOrient
      else
        writeMessage ("Invalid newOrient in turtleSetOrientation function", messageLevel.ERROR)
      end
    elseif (currOrient == direction.RIGHT) then
      if (newOrient == direction.BACK) then
        turtle.turnRight()
        currOrient = newOrient
      elseif (newOrient == direction.LEFT) then
        turtle.turnRight()
        turtle.turnRight()
        currOrient = newOrient
      elseif (newOrient == direction.FORWARD) then
        turtle.turnLeft()
        currOrient = newOrient
      else
        writeMessage ("Invalid newOrient in turtleSetOrientation function", messageLevel.ERROR)
      end
    elseif (currOrient == direction.BACK) then
      if (newOrient == direction.LEFT) then
        turtle.turnRight()
        currOrient = newOrient
      elseif (newOrient == direction.FORWARD) then
        turtle.turnRight()
        turtle.turnRight()
        currOrient = newOrient
      elseif (newOrient == direction.RIGHT) then
        turtle.turnLeft()
        currOrient = newOrient
      else
        writeMessage ("Invalid newOrient in turtleSetOrientation function", messageLevel.ERROR)
      end
    elseif (currOrient == direction.LEFT) then
      if (newOrient == direction.FORWARD) then
        turtle.turnRight()
        currOrient = newOrient
      elseif (newOrient == direction.RIGHT) then
        turtle.turnRight()
        turtle.turnRight()
        currOrient = newOrient
      elseif (newOrient == direction.BACK) then
        turtle.turnLeft()
        currOrient = newOrient
      else
        writeMessage ("Invalid newOrient in turtleSetOrientation function", messageLevel.ERROR)
      end
    else
      writeMessage ("Invalid currOrient in turtleTurn function", messageLevel.ERROR)
    end
  end
end
 
-- ********************************************************************************** --
-- Determines if a particular block is considered a noise block or not. A noise
-- block is one that is a standard block in the game (stone, dirt, gravel etc.) and
-- is one to ignore as not being an ore. Function works by comparing the block
-- in question against a set of blocks in the turtle's inventory which are known not to
-- be noise blocks. Param is the function to use to compare the block for a noise block
-- ********************************************************************************** --
function isNoiseBlock(compareFn)
 
  -- Consider air to be a noise block
  local returnVal = false
  local seamLoop = 1
  local prevSelectedSlot  

  -- If the currently selected slot is a noise block, then compare against this first
  -- so that the slot doesn't need to be selected again (there is a 0.05s cost to do
  -- this even if it is the currently selected slot)
  if (currentlySelectedSlot <= noiseBlocksCount) then
    returnVal = compareFn()
  end

  if (returnVal == false) then
    prevSelectedSlot = currentlySelectedSlot
    while((returnVal == false) and (seamLoop <= noiseBlocksCount)) do
      if (seamLoop ~= prevSelectedSlot) then
        turtle.select(seamLoop) 
        currentlySelectedSlot = seamLoop
        returnVal = compareFn()
      end
      seamLoop = seamLoop + 1
    end
  end

  -- Return the calculated value
  return returnVal
 
end
 
-- ********************************************************************************** --
-- Determines if a particular block is a chest. Returns false if it is not a chest
-- or chests are not being detected
-- ********************************************************************************** --
function isChestBlock(compareFn)
 
  -- Check the block in the appropriate direction to see whether it is a chest. Only
  -- do this if we are looking for chests
  local returnVal = false
  if (lookForChests == true) then
    turtle.select(15)
    currentlySelectedSlot = 15
    returnVal = compareFn()
  end
 
  -- Return the calculated value
  return returnVal
 
end
 
-- ********************************************************************************** --
-- Function to calculate the number of non seam blocks in the turtle's inventory. This
-- is all of the blocks at the start of the inventory (before the first empty slot is
-- found
-- ********************************************************************************** --
function determineNoiseBlocksCountCount()
  -- Determine the location of the first empty inventory slot. All items before this represent
  -- noise items.
  local foundFirstBlankInventorySlot = false
  noiseBlocksCount = 1
  while ((noiseBlocksCount < 16) and (foundFirstBlankInventorySlot == false)) do
    if (turtle.getItemCount(noiseBlocksCount) > 0) then
      noiseBlocksCount = noiseBlocksCount + 1
    else
      foundFirstBlankInventorySlot = true
    end
  end
  noiseBlocksCount = noiseBlocksCount - 1
 
  -- Determine whether a chest was provided, and hence whether we should support
  -- looking for chests
  if (turtle.getItemCount(15) > 0) then
    lookForChests = true
    lastEmptySlot = 14
    miningOffset = 0
    writeMessage("Looking for chests...", messageLevel.DEBUG)
  else
    lastEmptySlot = 15
    miningOffset = 1
    writeMessage("Ignoring chests...", messageLevel.DEBUG)
  end
end
 
-- ********************************************************************************** --
-- Creates a quarry mining out only ores and leaving behind any noise blocks
-- ********************************************************************************** --
function createQuarry()
 
  -- Determine the top mining layer layer. The turtle mines in layers of 3, and the bottom layer
  -- is the layer directly above bedrock.
  --
  -- The actual layer that the turtle operates in is the middle of these three layers,
  -- so determine the top layer
  local topMiningLayer = startHeight + ((bottomLayer - startHeight - 2) % 3) - 1 + miningOffset
 
  -- If the top layer is up, then ignore it and move to the next layer
  if (topMiningLayer > currY) then
    topMiningLayer = topMiningLayer - 3
  end
 
  local startedLayerToRight = true -- Only used where the quarry is of an odd width
 
  -- Loop over each mining row
  local miningLevel
  for miningLevel = (bottomLayer + miningOffset), topMiningLayer, 3 do
    writeMessage("Mining Layer: "..miningLevel, messageLevel.INFO)
    haveBeenAtZeroZeroOnLayer = false
 
    -- While the initial shaft is being dug out, set the level to return to in order to unload
    -- to the just take the turtle straight back up
    if (miningLevel == (bottomLayer + miningOffset)) then
      levelToReturnTo = startHeight
    end

    -- Move to the correct level to start mining
    if (currY > miningLevel) then
      while (currY > miningLevel) do
        turtleDown()
      end
    elseif (currY < miningLevel) then
      while (currY < miningLevel) do
        turtleUp()
      end
    end

    -- Set the layer to return via when returning to the surface as the one below the currently
    -- mined one
    if (miningLevel == (bottomLayer + miningOffset)) then
      levelToReturnTo = (bottomLayer + miningOffset)
    else
      levelToReturnTo = miningLevel - 3
    end
 
    -- Move turtle into the correct orientation to start mining (if this is the
    -- first row to be mined, then don't need to turn, otherwise turn towards the next
    -- mining section)

    writeMessage("Mining Level: "..miningLevel..", Bottom Layer: "..bottomLayer..", Mining Offset: "..miningOffset, messageLevel.DEBUG)

    if (miningLevel > (bottomLayer + miningOffset)) then
      -- Turn towards the next mining layer
      if (quarryWidth % 2 == 0) then
        -- An even width quarry, always turn right
        turtleTurn(direction.RIGHT)
      else
        -- Turn the opposite direction to that which we turned before
        if (startedLayerToRight == true) then
          turtleTurn(direction.LEFT)
          startedLayerToRight = false
        else
          turtleTurn(direction.RIGHT)
          startedLayerToRight = true
        end
      end
    end
 
    local mineRows
    local onNearSideOfQuarry = true
    local diggingAway = true
    for mineRows = 1, quarryWidth do

      -- If this is not the first row, then get into position to mine the next row
      if ((mineRows == 1) and (lookForChests == false)) then
        -- Not looking for chests, check the block below for being an ore. Only do this
        -- if we're not looking for chests since the program doesn't support chests in
        -- bedrock
        if (isNoiseBlock(turtle.compareDown) == false) then
          turtle.digDown()
          ensureInventorySpace()
        end
      elseif (mineRows > 1) then
        -- Move into position for mining the next row
        if (onNearSideOfQuarry == diggingAway) then
          if (startedLayerToRight == true) then
            turtleTurn(direction.LEFT)
          else
            turtleTurn(direction.RIGHT)
          end
        else
          if (startedLayerToRight == true) then
            turtleTurn(direction.RIGHT)
          else
            turtleTurn(direction.LEFT)
          end
        end
 
        turtleForward()
 
        -- Before making the final turn, check the block below. Do this
        -- now because if it is a chest, then we want to back up and 
        -- approach it from the side (so that we don't lose items if we 
        -- have to return to the start through it). 
        --
        -- This is the point at which it is safe to back up without moving
        -- out of the quarry area (unless at bedrock in which case don't bother
        -- as we'll be digging down anyway)
        if (miningLevel ~= bottomLayer) then
          if (isNoiseBlock(turtle.compareDown) == false) then
            -- If we are not looking for chests, then just dig it (it takes 
            -- less time to try to dig and fail as it does to do detect and
            -- only dig if there is a block there)
            if (lookForChests == false) then
              turtle.digDown()
              ensureInventorySpace()
            elseif (turtle.detectDown() == true) then
              if (isChestBlock(turtle.compareDown) == true) then
                -- There is a chest block below. Move back and approach
                -- from the side to ensure that we don't need to return to
                -- start through the chest itself (potentially losing items) 
                turtleBack()
                turtleDown()
                emptyChest(turtle.suck)
                turtleUp()
                turtleForward()
                turtle.digDown()
                ensureInventorySpace()
              else
                turtle.digDown()
                ensureInventorySpace()
              end
            end
          end
        end
 
        -- Move into final position for mining the next row
        if (onNearSideOfQuarry == diggingAway) then
          if (startedLayerToRight == true) then
            turtleTurn(direction.LEFT)
          else
            turtleTurn(direction.RIGHT)
          end
        else
          if (startedLayerToRight == true) then
            turtleTurn(direction.RIGHT)
          else
            turtleTurn(direction.LEFT)
          end
        end
      end
 
      -- Dig to the other side of the quarry
      local blocksMined
      for blocksMined = 0, (quarryWidth - 1) do
        if (blocksMined > 0) then
          -- Only move forward if this is not the first space
          turtleForward()
        end

        -- If the current block is (0,0), then record the fact that the 
        -- turtle has been through this block and what it's orientation was and update the layer
        -- that it should return via to get back to the surface (it no longer needs to go down
        -- a level to prevent losing ores). 
        if ((currX == 0) and (currZ == 0)) then
          -- Am at (0, 0). Remember this, and what direction I was facing so that the quickest route
          -- to the surface can be taken
          levelToReturnTo = miningLevel
          haveBeenAtZeroZeroOnLayer = true
          orientationAtZeroZero = currOrient
        end

        -- If currently at bedrock, just move down until the turtle can't go any
        -- further. This allows the blocks within the bedrock to be mined
        if (miningLevel == bottomLayer) then
          -- Temporarily turn off looking for chests to increase bedrock mining speed (this
          -- means that the program doesn't support chests below level 5 - but I think
          -- they they don't exist anyway)
          local lookForChestsPrev = lookForChests
          lookForChests = false

          -- Manually set the flag to determine whether the turtle should try to move first or
          -- dig first. At bedrock, is very rarely any space

          -- Just above bedrock layer, dig down until can't dig any lower, and then
          -- come back up. This replicates how the quarry functions
          lastMoveNeededDig = true
          local moveDownSuccess = turtleDown()
          while (moveDownSuccess == true) do
            moveDownSuccess = turtleDown()
          end

          -- Know that we are moving back up through air, therefore set the flag to force the
          -- turtle to try moving first 
          lastMoveNeededDig = false

          -- Have now hit bedrock, move back to the mining layer
          while (currY < bottomLayer) do
            turtleUp()
          end

          -- Now back at the level above bedrock, again reset the flag to tell the turtle to 
          -- try digging again (because it is rare to find air at bedrock level)
          lastMoveNeededDig = false

          -- Reset the look for chests value
          lookForChests = lookForChestsPrev
        elseif ((blocksMined > 0) and ((currX ~= 0) or (currZ ~= 0))) then
          -- This isn't the first block of the row, nor are we at (0, 0) so we need to check the
          -- block below

          -- Check the block down for being a noise block (don't need to check the first
          -- block as it has already been checked in the outer loop)
          if (isNoiseBlock(turtle.compareDown) == false) then
            -- If we are not looking for chests, then just dig it (it takes 
            -- less time to try to dig and fail as it does to do detect and
            -- only dig if there is a block there)
            if (lookForChests == false) then
              turtle.digDown()
              ensureInventorySpace()
            elseif (turtle.detectDown() == true) then
              if (isChestBlock(turtle.compareDown) == true) then
                -- There is a chest block below. Move back and approach
                -- from the side to ensure that we don't need to return to
                -- start through the chest itself (potentially losing items) 
                turtleBack()
                turtleDown()
                emptyChest(turtle.suck)
                turtleUp()
                turtleForward()
                turtle.digDown()
                ensureInventorySpace()
              else
                turtle.digDown()
                ensureInventorySpace()
              end
            end
          end
        end
       
        -- Check the block above for ores (if we're not a (0, 0) in which case
        -- we know it's air)
        if ((currX ~= 0) or (currZ ~= 0)) then
          if (isNoiseBlock(turtle.compareUp) == false) then
            -- If we are not looking for chests, then just dig it (it takes 
            -- less time to try to dig and fail as it does to do detect and
            -- only dig if there is a block there)
            if (lookForChests == false) then
              turtle.digUp()
              ensureInventorySpace()
            elseif (turtle.detectUp() == true) then
              -- Determine if it is a chest before digging it
              if (isChestBlock(turtle.compareUp) == true) then
                -- There is a chest block above. Empty it before digging it
                emptyChest(turtle.suckUp)
                turtle.digUp()
                ensureInventorySpace()
              else
                turtle.digUp()
                ensureInventorySpace()
              end
            end
          end
        end
      end
 
      -- Am now at the other side of the quarry
      onNearSideOfQuarry = not onNearSideOfQuarry
    end
 
    -- If we were digging away from the starting point, will be digging
    -- back towards it on the next layer
    diggingAway = not diggingAway
  end
 
  -- Return to the start
  returnToStartAndUnload(false)
 
  -- Face forward
  turtleSetOrientation(direction.FORWARD)
end
 
-- ********************************************************************************** --
-- Main Function                                          
-- ********************************************************************************** --
-- Process the input arguments - storing them to global variables
local args = { ... }
local paramsOK = true

turtleId = os.getComputerLabel()
rednet.open("right")

if (#args == 1) then
  quarryWidth = tonumber(args[1])
  local x, y, z = gps.locate(5)
  startHeight = y
  if (startHeight == nil) then
    writeMessage("Can't locate GPS", messageLevel.FATAL)
    paramsOK = false
  end
elseif (#args == 2) then
  quarryWidth = tonumber(args[1])
  startHeight = tonumber(args[2])
else
  writeMessage("Usage: OreQuarry <diameter> <turtleY>", messageLevel.FATAL)
  paramsOK = false
end

if (paramsOK == true) then
  if ((startHeight < 6) or (startHeight > 128)) then
    writeMessage("turtleY must be between 6 and 128", messageLevel.FATAL)
    paramsOK = false
  end
 
  if ((quarryWidth < 2) or (quarryWidth > 64)) then
    writeMessage("diameter must be between 2 and 64", messageLevel.FATAL)
    paramsOK = false
  end
end
 
if (paramsOK == true) then
  writeMessage("----------------------------------", messageLevel.INFO)
  writeMessage("** Ore Quarry v0.53 by AustinKK **", messageLevel.INFO)
  writeMessage("----------------------------------", messageLevel.INFO)
 
  -- Set the turtle's starting position
  currX = 0
  currY = startHeight
  currZ = 0
  currOrient = direction.FORWARD
 
  -- Calculate which blocks in the inventory signify noise blocks
  determineNoiseBlocksCountCount()
 
  if ((noiseBlocksCount == 0) or (noiseBlocksCount > 13)) then
    writeMessage("No noise blocks have been been added. Please place blocks that the turtle should not mine (e.g. Stone, Dirt, Gravel etc.) in the first few slots of the turtle\'s inventory. The first empty slot signifies the end of the noise blocks.", messageLevel.FATAL)
  else
    -- Create a Quarry
    turtle.select(1)
    currentlySelectedSlot = 1
    createQuarry()
  end
end